[
  {
    "title": "Building My First Electron App",
    "publishedAt": "2022-05-22",
    "summary": "Learn how I created a simple application to convert and download YouTube videos as MP3s.",
    "image": "/static/images/building-my-first-electron-app/banner.png",
    "body": {
      "raw": "\nI don't write a lot (though is something I want to change), but this site is some kind of playground to try new things. The other day stumbled upon a [list of personal websites of developers and designers](https://github.com/stars/brianlovin/lists/personal-websites) and going through them found some using [Contentlayer](https://www.contentlayer.dev/), it looked interesting, so let's try it!\n\n## What is Contentlayer?\n\n> Contentlayer turns your content into data - making it super easy to import MD(X) and CMS content in your app.\n\n## How to add it to your NextJS site?\n\nThe first step is to install the needed libraries:\n\n```bash\nyarn add contentlayer next-contentlayer\n```\n\nOnce the installation is complete, a `contentlayer.config.ts` file needs to be created in the root folder of your project. This is the file where all the content definition and project configuration are done.\n\nIn my case I only have one type of content, blog posts coming from MDX files.\n\n<CH.Section>\n\nUse `defineDocumentType` for each type of content type you want Contentlayer to manage. Using the [fields](focus://7:13) property we map [frontmatter](https://mdxjs.com/guides/frontmatter/) fields from the document to object properties you can freely use (and to typescript types!).\n\n```js contentlayer.config.ts\nimport { defineDocumentType } from \"contentlayer/source-files\";\n\nconst Post = defineDocumentType(() => ({\n  name: \"Post\",\n  filePathPattern: \"posts/*.mdx\",\n  bodyType: \"mdx\",\n  fields: {\n    title: { type: \"string\", required: true },\n    date: { type: \"date\", required: true },\n    tags: { type: \"list\", of: { type: \"string\" } },\n    image: { type: \"string\" },\n    excerpt: { type: \"string\" },\n  },\n  computedFields,\n}));\n```\n\nYou see that [computedFields](focus://14) property?\n\n</CH.Section>\n\n<CH.Section>\n\nThis are some kind of virtual fields that can go through and extra process, for example to [get the slug](focus://5:8) from the file name, or to get some extra metadata like [reading time](focus://2,9).\n\n```ts contentlayer.config.ts\nimport type { ComputedFields } from \"contentlayer/source-files\";\nimport readingTime from \"reading-time\";\n\nconst computedFields: ComputedFields = {\n  slug: {\n    type: \"string\",\n    resolve: (doc) => doc._raw.sourceFileName.replace(/\\.mdx$/, \"\"),\n  },\n  readingTime: { type: \"json\", resolve: (doc) => readingTime(doc.body.raw) },\n};\n```\n\n</CH.Section>\n\n<CH.Section>\n\nFinally we complete the configuration using `makeSource`. We need to [add the content types](focus://9) defined above and we have the option to set [extra configuration for MDX files, like using remark and rehype plugins](focus://2:4,10:16).\n\n```js contentlayer.config.ts\nimport { makeSource } from \"contentlayer/source-files\";\nimport slug from \"rehype-slug\";\nimport remarkGfm from \"remark-gfm\";\nimport { rehypeAccessibleEmojis } from \"rehype-accessible-emojis\";\n\nconst contentLayerConfig = makeSource(async () => {\n  return {\n    contentDirPath: \"content\",\n    documentTypes: [Post],\n    mdx: {\n      remarkPlugins: [remarkGfm],\n      rehypePlugins: [slug, rehypeAccessibleEmojis],\n    },\n  };\n});\n\nexport default contentLayerConfig;\n```\n\n</CH.Section>\n\nWith this we are almost done with the configuration, but since we are using NextJS we can hook up to its build process to autogenerate the content and enable live-reload. To do this we need to add some changes on `next.config.js`. In my case I'm using [next-compose-plugins](https://github.com/cyrilwanner/next-compose-plugins) so it looks like this:\n\n```js next.config.js focus=2,9\nconst withPlugins = require(\"next-compose-plugins\");\nconst { withContentlayer } = require(\"next-contentlayer\");\n\nconst nextConfig = {\n  // extra next config\n};\n\nmodule.exports = withPlugins([withContentlayer()], nextConfig);\n```\n\n## How to use it?\n\nWith everything in place, running `yarn dev` (or `yarn build` for production) will trigger Contentlayer build process, which generates several files inside the `node_modules/.contentlayer`folder which then you can import wherever you want to use them.\n\nFor my content I defined a content type called `Post`, so for example to look for the single post when a slug is accessed:\n\n```js pages/[slug].tsx focus=1,4:6\nimport { allPosts } from '.contentlayer/data';\n\nexport const getStaticProps = async ({ params }) => {\n\tconst post = allPosts.find(\n\t\t(post) => post.slug === (params?.slug as string),\n\t);\n\n\treturn {\n\t\tprops: {\n\t\t\tpost,\n\t\t},\n\t};\n};\n```\n\nAnd since I'm using MDX we need the `useMDXComponent` hook to render the content:\n\n```js pages/[slug].tsx focus=1,5,9\nimport { useMDXComponent } from \"next-contentlayer/hooks\";\nimport type { Post } from \".contentlayer/types\"; // Typescript type too!\n\nconst SinglePost = ({ post }: { post: Post }) => {\n  const Component = useMDXComponent(post.body.code);\n\n  return (\n    <article>\n      <Component />\n    </article>\n  );\n};\n```\n\nThat's it! Our `Post` object has access to all the properties we defined as `fields` and `computedFields` plus some extra (like the above `body.code` for MDX files).\n\nYou can see the complete changeset for this here: https://github.com/osiux/osiux.ws/pull/5/files\n\n## Caveats\n\nOnly major issue was that I was using a [remark plugin](https://github.com/MichaelDeBoey/gatsby-remark-embedder) (to embed media content) that is using an old [unified](https://github.com/unifiedjs/unified) version, while Contentlayer uses latest version and it was causing some kind of incompatibility.\n\n## Conclusion\n\nThe process to implement Contentlayer was pretty straightforward, currently the library lacks some documentation, but given its alpha state it's understandable, and looking at websites already using it made it easier to use.\n",
      "code": "var Component=(()=>{var h=Object.create;var s=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var u=Object.getOwnPropertyNames;var m=Object.getPrototypeOf,g=Object.prototype.hasOwnProperty;var f=(t,o)=>()=>(o||t((o={exports:{}}).exports,o),o.exports),y=(t,o)=>{for(var r in o)s(t,r,{get:o[r],enumerable:!0})},a=(t,o,r,n)=>{if(o&&typeof o==\"object\"||typeof o==\"function\")for(let i of u(o))!g.call(t,i)&&i!==r&&s(t,i,{get:()=>o[i],enumerable:!(n=p(o,i))||n.enumerable});return t};var b=(t,o,r)=>(r=t!=null?h(m(t)):{},a(o||!t||!t.__esModule?s(r,\"default\",{value:t,enumerable:!0}):r,t)),w=t=>a(s({},\"__esModule\",{value:!0}),t);var l=f((P,c)=>{c.exports=_jsx_runtime});var j={};y(j,{default:()=>C,frontmatter:()=>x});var e=b(l()),x={title:\"Building My First Electron App\",publishedAt:\"2022-05-22\",summary:\"Learn how I created a simple application to convert and download YouTube videos as MP3s.\",image:\"/static/images/building-my-first-electron-app/banner.png\"};function k(t={}){let{wrapper:o}=t.components||{};return o?(0,e.jsx)(o,Object.assign({},t,{children:(0,e.jsx)(r,{})})):r();function r(){let n=Object.assign({p:\"p\",a:\"a\",h2:\"h2\",blockquote:\"blockquote\",pre:\"pre\",code:\"code\"},t.components),{CH:i}=n;return i||d(\"CH\",!1,\"26:1-50:14\"),i.Section||d(\"CH.Section\",!0,\"26:1-50:14\"),(0,e.jsxs)(e.Fragment,{children:[(0,e.jsxs)(n.p,{children:[\"I don't write a lot (though is something I want to change), but this site is some kind of playground to try new things. The other day stumbled upon a \",(0,e.jsx)(n.a,{href:\"https://github.com/stars/brianlovin/lists/personal-websites\",children:\"list of personal websites of developers and designers\"}),\" and going through them found some using \",(0,e.jsx)(n.a,{href:\"https://www.contentlayer.dev/\",children:\"Contentlayer\"}),\", it looked interesting, so let's try it!\"]}),`\n`,(0,e.jsx)(n.h2,{children:\"What is Contentlayer?\"}),`\n`,(0,e.jsxs)(n.blockquote,{children:[`\n`,(0,e.jsx)(n.p,{children:\"Contentlayer turns your content into data - making it super easy to import MD(X) and CMS content in your app.\"}),`\n`]}),`\n`,(0,e.jsx)(n.h2,{children:\"How to add it to your NextJS site?\"}),`\n`,(0,e.jsx)(n.p,{children:\"The first step is to install the needed libraries:\"}),`\n`,(0,e.jsx)(n.pre,{children:(0,e.jsx)(n.code,{className:\"language-bash\",children:`yarn add contentlayer next-contentlayer\n`})}),`\n`,(0,e.jsxs)(n.p,{children:[\"Once the installation is complete, a \",(0,e.jsx)(n.code,{children:\"contentlayer.config.ts\"}),\" file needs to be created in the root folder of your project. This is the file where all the content definition and project configuration are done.\"]}),`\n`,(0,e.jsx)(n.p,{children:\"In my case I only have one type of content, blog posts coming from MDX files.\"}),`\n`,(0,e.jsxs)(i.Section,{children:[(0,e.jsxs)(n.p,{children:[\"Use \",(0,e.jsx)(n.code,{children:\"defineDocumentType\"}),\" for each type of content type you want Contentlayer to manage. Using the \",(0,e.jsx)(n.a,{href:\"focus://7:13\",children:\"fields\"}),\" property we map \",(0,e.jsx)(n.a,{href:\"https://mdxjs.com/guides/frontmatter/\",children:\"frontmatter\"}),\" fields from the document to object properties you can freely use (and to typescript types!).\"]}),(0,e.jsx)(n.pre,{children:(0,e.jsx)(n.code,{className:\"language-js\",children:`import { defineDocumentType } from \"contentlayer/source-files\";\n\nconst Post = defineDocumentType(() => ({\n  name: \"Post\",\n  filePathPattern: \"posts/*.mdx\",\n  bodyType: \"mdx\",\n  fields: {\n    title: { type: \"string\", required: true },\n    date: { type: \"date\", required: true },\n    tags: { type: \"list\", of: { type: \"string\" } },\n    image: { type: \"string\" },\n    excerpt: { type: \"string\" },\n  },\n  computedFields,\n}));\n`})}),(0,e.jsxs)(n.p,{children:[\"You see that \",(0,e.jsx)(n.a,{href:\"focus://14\",children:\"computedFields\"}),\" property?\"]})]}),`\n`,(0,e.jsxs)(i.Section,{children:[(0,e.jsxs)(n.p,{children:[\"This are some kind of virtual fields that can go through and extra process, for example to \",(0,e.jsx)(n.a,{href:\"focus://5:8\",children:\"get the slug\"}),\" from the file name, or to get some extra metadata like \",(0,e.jsx)(n.a,{href:\"focus://2,9\",children:\"reading time\"}),\".\"]}),(0,e.jsx)(n.pre,{children:(0,e.jsx)(n.code,{className:\"language-ts\",children:`import type { ComputedFields } from \"contentlayer/source-files\";\nimport readingTime from \"reading-time\";\n\nconst computedFields: ComputedFields = {\n  slug: {\n    type: \"string\",\n    resolve: (doc) => doc._raw.sourceFileName.replace(/\\\\.mdx$/, \"\"),\n  },\n  readingTime: { type: \"json\", resolve: (doc) => readingTime(doc.body.raw) },\n};\n`})})]}),`\n`,(0,e.jsxs)(i.Section,{children:[(0,e.jsxs)(n.p,{children:[\"Finally we complete the configuration using \",(0,e.jsx)(n.code,{children:\"makeSource\"}),\". We need to \",(0,e.jsx)(n.a,{href:\"focus://9\",children:\"add the content types\"}),\" defined above and we have the option to set \",(0,e.jsx)(n.a,{href:\"focus://2:4,10:16\",children:\"extra configuration for MDX files, like using remark and rehype plugins\"}),\".\"]}),(0,e.jsx)(n.pre,{children:(0,e.jsx)(n.code,{className:\"language-js\",children:`import { makeSource } from \"contentlayer/source-files\";\nimport slug from \"rehype-slug\";\nimport remarkGfm from \"remark-gfm\";\nimport { rehypeAccessibleEmojis } from \"rehype-accessible-emojis\";\n\nconst contentLayerConfig = makeSource(async () => {\n  return {\n    contentDirPath: \"content\",\n    documentTypes: [Post],\n    mdx: {\n      remarkPlugins: [remarkGfm],\n      rehypePlugins: [slug, rehypeAccessibleEmojis],\n    },\n  };\n});\n\nexport default contentLayerConfig;\n`})})]}),`\n`,(0,e.jsxs)(n.p,{children:[\"With this we are almost done with the configuration, but since we are using NextJS we can hook up to its build process to autogenerate the content and enable live-reload. To do this we need to add some changes on \",(0,e.jsx)(n.code,{children:\"next.config.js\"}),\". In my case I'm using \",(0,e.jsx)(n.a,{href:\"https://github.com/cyrilwanner/next-compose-plugins\",children:\"next-compose-plugins\"}),\" so it looks like this:\"]}),`\n`,(0,e.jsx)(n.pre,{children:(0,e.jsx)(n.code,{className:\"language-js\",children:`const withPlugins = require(\"next-compose-plugins\");\nconst { withContentlayer } = require(\"next-contentlayer\");\n\nconst nextConfig = {\n  // extra next config\n};\n\nmodule.exports = withPlugins([withContentlayer()], nextConfig);\n`})}),`\n`,(0,e.jsx)(n.h2,{children:\"How to use it?\"}),`\n`,(0,e.jsxs)(n.p,{children:[\"With everything in place, running \",(0,e.jsx)(n.code,{children:\"yarn dev\"}),\" (or \",(0,e.jsx)(n.code,{children:\"yarn build\"}),\" for production) will trigger Contentlayer build process, which generates several files inside the \",(0,e.jsx)(n.code,{children:\"node_modules/.contentlayer\"}),\"folder which then you can import wherever you want to use them.\"]}),`\n`,(0,e.jsxs)(n.p,{children:[\"For my content I defined a content type called \",(0,e.jsx)(n.code,{children:\"Post\"}),\", so for example to look for the single post when a slug is accessed:\"]}),`\n`,(0,e.jsx)(n.pre,{children:(0,e.jsx)(n.code,{className:\"language-js\",children:`import { allPosts } from '.contentlayer/data';\n\nexport const getStaticProps = async ({ params }) => {\n\tconst post = allPosts.find(\n\t\t(post) => post.slug === (params?.slug as string),\n\t);\n\n\treturn {\n\t\tprops: {\n\t\t\tpost,\n\t\t},\n\t};\n};\n`})}),`\n`,(0,e.jsxs)(n.p,{children:[\"And since I'm using MDX we need the \",(0,e.jsx)(n.code,{children:\"useMDXComponent\"}),\" hook to render the content:\"]}),`\n`,(0,e.jsx)(n.pre,{children:(0,e.jsx)(n.code,{className:\"language-js\",children:`import { useMDXComponent } from \"next-contentlayer/hooks\";\nimport type { Post } from \".contentlayer/types\"; // Typescript type too!\n\nconst SinglePost = ({ post }: { post: Post }) => {\n  const Component = useMDXComponent(post.body.code);\n\n  return (\n    <article>\n      <Component />\n    </article>\n  );\n};\n`})}),`\n`,(0,e.jsxs)(n.p,{children:[\"That's it! Our \",(0,e.jsx)(n.code,{children:\"Post\"}),\" object has access to all the properties we defined as \",(0,e.jsx)(n.code,{children:\"fields\"}),\" and \",(0,e.jsx)(n.code,{children:\"computedFields\"}),\" plus some extra (like the above \",(0,e.jsx)(n.code,{children:\"body.code\"}),\" for MDX files).\"]}),`\n`,(0,e.jsx)(n.p,{children:\"You can see the complete changeset for this here: https://github.com/osiux/osiux.ws/pull/5/files\"}),`\n`,(0,e.jsx)(n.h2,{children:\"Caveats\"}),`\n`,(0,e.jsxs)(n.p,{children:[\"Only major issue was that I was using a \",(0,e.jsx)(n.a,{href:\"https://github.com/MichaelDeBoey/gatsby-remark-embedder\",children:\"remark plugin\"}),\" (to embed media content) that is using an old \",(0,e.jsx)(n.a,{href:\"https://github.com/unifiedjs/unified\",children:\"unified\"}),\" version, while Contentlayer uses latest version and it was causing some kind of incompatibility.\"]}),`\n`,(0,e.jsx)(n.h2,{children:\"Conclusion\"}),`\n`,(0,e.jsx)(n.p,{children:\"The process to implement Contentlayer was pretty straightforward, currently the library lacks some documentation, but given its alpha state it's understandable, and looking at websites already using it made it easier to use.\"})]})}}var C=k;function d(t,o,r){throw new Error(\"Expected \"+(o?\"component\":\"object\")+\" `\"+t+\"` to be defined: you likely forgot to import, pass, or provide it.\"+(r?\"\\nIt\\u2019s referenced in your code at `\"+r+\"` in `/Users/weehongkoh/Workspace/js/weehong.dev/data/_mdx_bundler_entry_point-9eb98b9f-e5bd-4808-8119-a57815d25b2f.mdx`\":\"\"))}return w(j);})();\n;return Component;"
    },
    "_id": "article/2022-05-15-contentlayer-nextjs.mdx",
    "_raw": {
      "sourceFilePath": "article/2022-05-15-contentlayer-nextjs.mdx",
      "sourceFileName": "2022-05-15-contentlayer-nextjs.mdx",
      "sourceFileDir": "article",
      "contentType": "mdx",
      "flattenedPath": "article/2022-05-15-contentlayer-nextjs"
    },
    "type": "Article",
    "slug": "2022-05-15-contentlayer-nextjs"
  }
]